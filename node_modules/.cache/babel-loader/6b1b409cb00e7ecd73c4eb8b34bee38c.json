{"ast":null,"code":"import React, { Fragment } from 'react';\nimport { gsap as gsap$2 } from 'gsap';\nimport { isForwardRef, isFragment } from 'react-is';\nimport { ScrollTrigger as ScrollTrigger$1 } from 'gsap/dist/ScrollTrigger';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar PlayState;\n\n(function (PlayState) {\n  PlayState[\"play\"] = \"play\";\n  PlayState[\"restart\"] = \"restart\";\n  PlayState[\"reverse\"] = \"reverse\";\n  PlayState[\"restartReverse\"] = \"restartReverse\";\n  PlayState[\"stop\"] = \"stop\";\n  PlayState[\"stopEnd\"] = \"stopEnd\";\n  PlayState[\"pause\"] = \"pause\";\n  PlayState[\"resume\"] = \"resume\";\n})(PlayState || (PlayState = {}));\n\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function (searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}\n\nvar setPlayState = function setPlayState(playState, prevPlayState, tween) {\n  if (tween === void 0) {\n    tween = null;\n  }\n\n  if (tween && playState && playState !== prevPlayState) {\n    if (playState === PlayState.play) {\n      tween.play();\n    } else if (playState === PlayState.restart) {\n      tween.restart(true);\n    } else if (playState === PlayState.reverse) {\n      tween.reverse();\n    } else if (playState === PlayState.restartReverse) {\n      tween.reverse(0);\n    } else if (playState === PlayState.stop) {\n      tween.pause(0);\n    } else if (playState === PlayState.stopEnd) {\n      tween.reverse(0);\n      tween.pause();\n    } else if (playState === PlayState.pause) {\n      tween.pause();\n    } else if (playState === PlayState.resume) {\n      tween.resume();\n    }\n  }\n};\n\nvar setInitialPlayState = function setInitialPlayState(tweenOrTimeline, props) {\n  var playState = props.playState;\n\n  if (playState) {\n    setPlayState(playState, PlayState.play, tweenOrTimeline);\n  }\n};\n\nvar getInitialPaused = function getInitialPaused(playState) {\n  return playState && (playState === PlayState.stop || playState === PlayState.stopEnd || playState === PlayState.pause);\n};\n\nvar getTweenFunction = function getTweenFunction(targets, props, context) {\n  var _context$getPlugins;\n\n  var _props$duration = props.duration,\n      duration = _props$duration === void 0 ? 1 : _props$duration,\n      from = props.from,\n      to = props.to,\n      stagger = props.stagger,\n      playState = props.playState,\n      onCompleteAll = props.onCompleteAll,\n      onCompleteAllParams = props.onCompleteAllParams,\n      onCompleteAllScope = props.onCompleteAllScope,\n      onStartAll = props.onStartAll,\n      vars = _objectWithoutPropertiesLoose(props, [\"children\", \"wrapper\", \"duration\", \"from\", \"to\", \"stagger\", \"progress\", \"totalProgress\", \"playState\", \"disabled\", \"onlyInvalidateTo\", \"onCompleteAll\", \"onCompleteAllParams\", \"onCompleteAllScope\", \"onStartAll\", \"position\", \"target\"]);\n\n  var tweenFunction;\n  var paused = getInitialPaused(playState);\n  var plugins = (_context$getPlugins = context === null || context === void 0 ? void 0 : context.getPlugins(context === null || context === void 0 ? void 0 : context.plugins, targets)) !== null && _context$getPlugins !== void 0 ? _context$getPlugins : {};\n\n  if (from && to) {\n    // special props like paused always go in the toVars parameter\n    tweenFunction = gsap$2.fromTo(targets, from, _extends({\n      stagger: stagger,\n      duration: duration,\n      paused: paused\n    }, to, vars, plugins));\n  } else if (to) {\n    tweenFunction = gsap$2.to(targets, _extends({\n      stagger: stagger,\n      duration: duration,\n      paused: paused\n    }, to, vars, plugins));\n  } else {\n    tweenFunction = gsap$2.from(targets, _extends({\n      stagger: stagger,\n      duration: duration,\n      paused: paused\n    }, from, vars, plugins));\n  } // if multiple tweens (stagger), wrap them in a timeline\n  // TODO: if it's already an timeline add event handlers\n\n\n  if (Array.isArray(tweenFunction)) {\n    tweenFunction.forEach(function (t) {\n      t.paused(false);\n    });\n    tweenFunction = gsap$2.timeline(_extends({}, vars, {\n      tweens: tweenFunction,\n      smoothChildTiming: true,\n      onComplete: onCompleteAll,\n      onCompleteParams: onCompleteAllParams,\n      onCompleteScope: onCompleteAllScope,\n      onStart: onStartAll\n    }));\n  }\n\n  return tweenFunction;\n};\n\nvar isEqual = function isEqual(obj1, obj2) {\n  // very easy equal check\n  // attention: if the order of properties are different it returns false\n  return JSON.stringify(obj1) === JSON.stringify(obj2);\n};\n\nfunction getReactNode(dom, traverseUp) {\n  if (traverseUp === void 0) {\n    traverseUp = 0;\n  }\n\n  var key = Object.keys(dom !== null && dom !== void 0 ? dom : {}).find(function (key) {\n    return key.startsWith('__reactInternalInstance$') || key.startsWith('__reactFiber$');\n  });\n  var domFiber = key && dom[key];\n  if (!domFiber) return null; // react <16\n\n  if (domFiber._currentElement) {\n    var _compFiber = domFiber._currentElement._owner;\n\n    for (var i = 0; i < traverseUp; i++) {\n      _compFiber = _compFiber._currentElement._owner;\n    }\n\n    return _compFiber._instance;\n  } // react 16+\n\n\n  if (domFiber.stateNode) {\n    return domFiber.stateNode;\n  }\n\n  var getCompFiber = function getCompFiber(fiber) {\n    //return fiber._debugOwner; // this also works, but is __DEV__ only\n    var parentFiber = fiber[\"return\"];\n\n    while (typeof parentFiber.type == 'string') {\n      parentFiber = parentFiber[\"return\"];\n    }\n\n    return parentFiber;\n  };\n\n  var compFiber = getCompFiber(domFiber);\n\n  for (var _i = 0; _i < traverseUp; _i++) {\n    compFiber = getCompFiber(compFiber);\n  }\n\n  return compFiber.stateNode;\n}\n\nvar getRefProp = function getRefProp(child, addTarget) {\n  // has to be tested if it works, which lib does still use innerRef?\n  if (child.props.innerRef) {\n    return {\n      innerRef: function innerRef(target) {\n        addTarget(target);\n        var innerRef = child.props.innerRef;\n        if (typeof innerRef === 'function') innerRef(target);else if (innerRef) innerRef.current = target;\n      }\n    };\n  }\n\n  return {\n    ref: function ref(target) {\n      addTarget(target);\n      var ref = child.ref;\n      if (typeof ref === 'function') ref(target);else if (ref) ref.current = target;\n    }\n  };\n};\n\nvar setOrAddTarget = function setOrAddTarget(target, setTarget, addTarget) {\n  var reactNode = getReactNode(target);\n\n  if (reactNode) {\n    addTarget(reactNode);\n  } else if (target) {\n    Object.keys(target).forEach(function (key) {\n      var elementRef = target[key];\n\n      if (typeof elementRef === 'object' && elementRef.current) {\n        if (Array.isArray(elementRef.current)) {\n          elementRef.current.forEach(function (singleRef) {\n            setTarget(key, singleRef);\n          });\n        } else {\n          setTarget(key, elementRef.current);\n        }\n      }\n    });\n  }\n};\n\nvar getTargetRefProp = function getTargetRefProp(child, setTarget, addTarget) {\n  // has to be tested if it works, which lib does still use innerRef?\n  if (child.props.innerRef) {\n    return {\n      innerRef: function innerRef(target) {\n        setOrAddTarget(target, setTarget, addTarget); // merge refs\n\n        var innerRef = child.props.innerRef;\n        if (typeof innerRef === 'function') innerRef(target);else if (innerRef) innerRef.current = target;\n      }\n    };\n  }\n\n  return {\n    ref: function ref(target) {\n      setOrAddTarget(target, setTarget, addTarget); // merge refs\n\n      var ref = child.ref;\n      if (typeof ref === 'function') ref(target);else if (ref) ref.current = target;\n    }\n  };\n};\n\nvar nullishCoalescing = function nullishCoalescing(value, ifNullish) {\n  if (value === null || typeof value === 'undefined') {\n    return ifNullish;\n  }\n\n  return value;\n};\n\nvar setProps = function setProps(tweenOrTimeline, props, prevProps) {\n  if (props.progress !== undefined && props.progress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.progress)) {\n    tweenOrTimeline.progress(props.progress);\n  }\n\n  if (props.totalProgress !== undefined && props.totalProgress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.totalProgress)) {\n    tweenOrTimeline.totalProgress(props.totalProgress);\n  }\n\n  if (tweenOrTimeline.duration !== undefined && props.duration && props.duration !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.duration)) {\n    tweenOrTimeline.duration(props.duration);\n  }\n};\n\nvar Context = /*#__PURE__*/React.createContext({\n  registerConsumer: function registerConsumer() {},\n  getPlugins: function getPlugins() {},\n  plugins: {}\n});\n\nvar Provider = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Provider, _React$Component);\n\n  function Provider(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.consumers = [];\n    _this.plugins = {};\n    _this.registerConsumer = _this.registerConsumer.bind(_assertThisInitialized(_this));\n    _this.getContextValue = _this.getContextValue.bind(_assertThisInitialized(_this));\n    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));\n    _this.getPlugins = _this.getPlugins.bind(_assertThisInitialized(_this));\n    _this.renderWithProvider = _this.renderWithProvider.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Provider.prototype;\n\n  _proto.registerConsumer = function registerConsumer(consumer) {\n    this.consumers.push(consumer);\n  };\n\n  _proto.getContextValue = function getContextValue(plugin) {\n    if (plugin === void 0) {\n      plugin = {};\n    }\n\n    return {\n      registerConsumer: this.registerConsumer,\n      // plugins: { ...this.context.plugins, ...plugin },\n      plugins: plugin,\n      getPlugins: this.getPlugins\n    };\n  };\n\n  _proto.getPlugin = function getPlugin(props, targets) {\n    return {};\n  };\n\n  _proto.getPlugins = function getPlugins(plugins, targets) {\n    var _this2 = this;\n\n    return Object.keys(plugins !== null && plugins !== void 0 ? plugins : {}).reduce(function (acc, plugin) {\n      if (Object.prototype.hasOwnProperty.call(plugins, plugin)) {\n        var _extends2; // @ts-ignore\n\n\n        return _extends({}, acc, (_extends2 = {}, _extends2[plugin] = _this2.getPlugin(plugins[plugin], targets), _extends2));\n      }\n\n      return acc;\n    }, {});\n  };\n\n  _proto.renderWithProvider = function renderWithProvider(output, plugin) {\n    return React.createElement(Context.Provider, {\n      value: this.getContextValue(plugin)\n    }, output);\n  };\n\n  return Provider;\n}(React.Component);\n\nProvider.contextType = Context;\nvar gsap;\n\nvar _interpolate;\n\nvar _getProp;\n\nvar _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== 'undefined' && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\n\nfunction getDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\nfunction getCircleLength(el) {\n  return 2 * Math.PI * parseFloat(nullishCoalescing(el.getAttribute('r'), '1') || '0');\n}\n\nfunction getRectLength(el) {\n  return parseFloat(nullishCoalescing(el.getAttribute('width'), '1') || '0') * 2 + parseFloat(nullishCoalescing(el.getAttribute('height'), '1') || '0') * 2;\n}\n\nfunction getLineLength(el) {\n  return getDistance({\n    x: parseFloat(nullishCoalescing(el.getAttribute('x1'), '1') || '0'),\n    y: parseFloat(nullishCoalescing(el.getAttribute('y1'), '1') || '0')\n  }, {\n    x: parseFloat(nullishCoalescing(el.getAttribute('x2'), '1') || '0'),\n    y: parseFloat(nullishCoalescing(el.getAttribute('y2'), '1') || '0')\n  });\n}\n\nfunction getPolylineLength(el) {\n  var points = el.points;\n  var totalLength = 0;\n  var previousPos = undefined;\n\n  for (var i = 0; i < points.numberOfItems; i++) {\n    var currentPos = points.getItem(i);\n    if (previousPos) totalLength += getDistance(previousPos, currentPos);\n    previousPos = currentPos;\n  }\n\n  return totalLength;\n}\n\nfunction getPolygonLength(el) {\n  var points = el.points;\n  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n} // if path is splitted into multiple move commands then return longest path\n\n\nfunction getPathLength(el) {\n  if (!el.hasAttribute('d')) {\n    return el.getTotalLength();\n  }\n\n  var d = el.getAttribute('d');\n  var pathString = d ? d.replace(/m/gi, 'M') : null;\n\n  if (!pathString) {\n    return el.getTotalLength();\n  }\n\n  var paths = pathString.split('M').filter(function (path) {\n    return path !== '';\n  }).map(function (path) {\n    return \"M\" + path;\n  });\n\n  if (paths.length === 1) {\n    return el.getTotalLength();\n  }\n\n  var maxLength = 0;\n  paths.forEach(function (path) {\n    var pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    pathElement.setAttribute('d', path);\n    maxLength = Math.max(maxLength, pathElement.getTotalLength());\n  });\n  return maxLength;\n}\n\nfunction getTotalLength(el) {\n  if (el.getTotalLength) {\n    return getPathLength(el);\n  }\n\n  switch (el.tagName.toLowerCase()) {\n    case 'circle':\n      return getCircleLength(el);\n\n    case 'rect':\n      return getRectLength(el);\n\n    case 'line':\n      return getLineLength(el);\n\n    case 'polyline':\n      return getPolylineLength(el);\n\n    case 'polygon':\n      return getPolygonLength(el);\n\n    default:\n      return 0;\n  }\n}\n\nvar SvgDrawPlugin = {\n  version: '2.0.0',\n  name: 'svgDraw',\n  register: function register(core, Plugin, propTween) {\n    gsap = core;\n    _interpolate = gsap.utils.interpolate;\n    _getProp = gsap.getProperty;\n  },\n  init: function init(target, value, _tween, index, targets) {\n    var length = getTotalLength(target);\n    var lengthParam = value;\n    var offsetParam = 0;\n\n    if (Array.isArray(value)) {\n      lengthParam = value[0];\n\n      if (value.length >= 2) {\n        offsetParam = value[1] * -1;\n      }\n    }\n\n    var data = this;\n    data.target = target;\n    data.strokeDashoffset = _interpolate(_getProp(target, 'stroke-dashoffset'), length * offsetParam);\n    data.strokeDasharray = _interpolate(_getProp(target, 'stroke-dasharray'), [lengthParam * length, length]);\n  },\n  render: function render(progress, data) {\n    data.target.setAttribute('stroke-dashoffset', data.strokeDashoffset(progress));\n    data.target.setAttribute('stroke-dasharray', data.strokeDasharray(progress));\n  }\n};\n_getGSAP() && gsap.registerPlugin(SvgDrawPlugin);\nvar gsap$1;\n\nvar _interpolate$1;\n\nvar _format;\n\nvar _getGSAP$1 = function _getGSAP() {\n  return gsap$1 || typeof window !== 'undefined' && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;\n};\n\nvar CountPlugin = {\n  version: '1.0.0',\n  name: 'count',\n  register: function register(core, Plugin, propTween) {\n    gsap$1 = core;\n    _interpolate$1 = gsap$1.utils.interpolate;\n\n    _format = function _format(value) {\n      return parseInt(value.toString(), 10);\n    };\n  },\n  init: function init(target, value, _tween, index, targets) {\n    var inputValue = value;\n    var format = _format;\n\n    if (typeof value === 'object') {\n      inputValue = nullishCoalescing(value.value, 0);\n\n      if (value.format) {\n        format = value.format;\n      }\n    }\n\n    var initialCount = parseFloat(target.innerText);\n    var data = this;\n    data.target = target;\n    data.count = _interpolate$1(initialCount, parseFloat(inputValue.toString()));\n    data.format = format;\n  },\n  render: function render(progress, data) {\n    data.target.innerText = data.format(data.count(progress));\n  }\n};\n_getGSAP$1() && gsap$1.registerPlugin(CountPlugin);\ngsap$2.registerPlugin(SvgDrawPlugin); // @ts-ignore\n\ngsap$2.registerPlugin(CountPlugin);\n\nvar Tween = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Tween, _React$Component);\n\n  function Tween(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.targets = [];\n    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Tween.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.createTween(); // props at mount\n\n    setProps(this.tween, this.props);\n    setInitialPlayState(this.tween, this.props);\n    this.context.registerConsumer(this);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.tween) {\n      this.tween.kill();\n    }\n  };\n\n  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {\n    this.targets = [];\n    return null;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this$props = this.props,\n        children = _this$props.children,\n        to = _this$props.to,\n        playState = _this$props.playState,\n        disabled = _this$props.disabled,\n        onlyInvalidateTo = _this$props.onlyInvalidateTo,\n        vars = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"wrapper\", \"duration\", \"from\", \"to\", \"stagger\", \"progress\", \"totalProgress\", \"playState\", \"disabled\", \"onlyInvalidateTo\", \"onCompleteAll\", \"onCompleteAllParams\", \"onCompleteAllScope\", \"onStartAll\", \"position\", \"target\"]); // if children change create a new tween\n    // TODO: replace easy length check with fast equal check\n\n\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.createTween();\n    }\n\n    if (disabled) {\n      return;\n    } // execute function calls\n\n\n    setProps(this.tween, this.props, prevProps); // if \"to\" props are changed: reinit and restart tween\n\n    if (!isEqual(to, prevProps.to)) {\n      // is Tween\n      if (!this.tween.getChildren) {\n        this.tween.vars = _extends({}, to, vars);\n\n        if (onlyInvalidateTo) {\n          var progressTmp = this.tween.progress();\n          this.tween.progress(0).invalidate().progress(progressTmp);\n        } else {\n          this.tween.invalidate();\n        }\n      } // is Timeline\n      // TODO: not yet ready\n      else {\n        var delay = 0;\n        this.tween.getChildren(false, true, false).forEach(function (tween) {\n          tween.vars = _extends({}, to, vars, {\n            delay: delay\n          });\n          tween.invalidate(); // delay += stagger || 0;\n        });\n      }\n\n      if (!this.tween.paused()) {\n        this.tween.restart();\n      }\n    }\n\n    setPlayState(playState, prevProps.playState, this.tween);\n  };\n\n  _proto.createTween = function createTween() {\n    if (this.tween) {\n      this.tween.kill();\n    }\n\n    if (this.props.children) {\n      this.tween = getTweenFunction(this.targets, this.props, this.context);\n    } else {\n      // why this is needed?\n      this.tween = function () {};\n    }\n  };\n\n  _proto.getGSAP = function getGSAP() {\n    return this.tween;\n  };\n\n  _proto.setGSAP = function setGSAP(tween) {\n    this.tween = tween;\n  };\n\n  _proto.addTarget = function addTarget(target) {\n    // target is null at unmount\n    if (target !== null) {\n      this.targets.push(target);\n    }\n  };\n\n  _proto.getTargets = function getTargets() {\n    return this.targets;\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        wrapper = _this$props2.wrapper;\n    var output = React.createElement(Fragment, null, React.Children.map(children, function (child) {\n      return React.cloneElement(child, getRefProp(child, _this2.addTarget));\n    }));\n\n    if (wrapper) {\n      return React.cloneElement(wrapper, [], output);\n    }\n\n    return output;\n  };\n\n  return Tween;\n}(React.Component);\n\nTween.displayName = 'Tween';\nTween.contextType = Context;\n\nvar Timeline = /*#__PURE__*/function (_Provider) {\n  _inheritsLoose(Timeline, _Provider);\n\n  function Timeline(props) {\n    var _this;\n\n    _this = _Provider.call(this, props) || this;\n    _this.targets = new Map();\n    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));\n    _this.setTarget = _this.setTarget.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Timeline.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.createTimeline(); // props at mount\n\n    setProps(this.timeline, this.props);\n    setInitialPlayState(this.timeline, this.props);\n    this.context.registerConsumer(this);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.timeline.kill();\n  };\n\n  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {\n    this.targets = new Map();\n    return null;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this$props = this.props,\n        children = _this$props.children,\n        playState = _this$props.playState; // if children change create a new timeline\n    // TODO: replace easy length check with fast equal check\n    // TODO: same for props.target?\n\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.createTimeline();\n    } // execute function calls\n\n\n    setProps(this.timeline, this.props, prevProps); // TODO: need rerender or something if target change?\n    // if (target !== prevProps.target) {\n    //   this.forceUpdate();\n    // }\n\n    setPlayState(playState, prevProps.playState, this.timeline);\n  };\n\n  _proto.createTimeline = function createTimeline() {\n    var _this$context$getPlug,\n        _this$context,\n        _this$context2,\n        _this2 = this;\n\n    var _this$props2 = this.props,\n        playState = _this$props2.playState,\n        labels = _this$props2.labels,\n        vars = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"target\", \"duration\", \"progress\", \"totalProgress\", \"playState\", \"labels\", \"position\"]);\n\n    if (this.timeline) {\n      this.timeline.kill();\n    }\n\n    var plugins = (_this$context$getPlug = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.getPlugins((_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.plugins, this.targets)) !== null && _this$context$getPlug !== void 0 ? _this$context$getPlug : {}; // init timeline\n\n    this.timeline = gsap$2.timeline(_extends({\n      smoothChildTiming: true,\n      paused: getInitialPaused(playState)\n    }, vars, plugins));\n\n    if (labels) {\n      labels.forEach(function (label) {\n        _this2.timeline.addLabel(label.label, label.position);\n      });\n    } // add tweens or nested timelines to timeline\n\n\n    this.consumers.forEach(function (consumer) {\n      // Tween with no children -> control Timeline target\n      if (consumer.tween && !consumer.props.children) {\n        var _consumer$props = consumer.props,\n            _position = _consumer$props.position,\n            _target = _consumer$props.target,\n            stagger = _consumer$props.stagger,\n            _vars = _objectWithoutPropertiesLoose(_consumer$props, [\"position\", \"target\", \"stagger\"]); // get target if not nullish\n\n\n        var targets = null;\n\n        if (_target !== null && typeof _target !== 'undefined') {\n          targets = _this2.targets.get(_target);\n        } // if no target found -> take all Timeline targets as target\n\n\n        var tween = getTweenFunction( // @ts-ignore\n        nullishCoalescing(targets, Array.from(_this2.targets.values())), _extends({\n          stagger: stagger\n        }, _vars));\n\n        _this2.timeline.add(tween, nullishCoalescing(_position, '+=0'));\n\n        consumer.setGSAP(tween);\n      } else {\n        var _position2 = consumer.props.position;\n\n        _this2.timeline.add(consumer.getGSAP(), nullishCoalescing(_position2, '+=0'));\n      }\n    });\n  };\n\n  _proto.getGSAP = function getGSAP() {\n    return this.timeline;\n  };\n\n  _proto.addTarget = function addTarget(target) {\n    if (target !== null) {\n      this.targets.set(this.targets.size, target);\n    }\n  };\n\n  _proto.setTarget = function setTarget(key, target) {\n    if (target !== null) {\n      if (this.targets.has(key)) {\n        var targets = this.targets.get(key);\n\n        if (Array.isArray(targets)) {\n          this.targets.set(key, [].concat(targets, [target]));\n        } else {\n          this.targets.set(key, [targets, target]);\n        }\n      } else {\n        this.targets.set(key, target);\n      }\n    }\n  };\n\n  _proto.setTargets = function setTargets(targets) {\n    this.targets = targets;\n  };\n\n  _proto.getTargets = function getTargets() {\n    return this.targets;\n  };\n\n  _proto.cloneElement = function cloneElement(child) {\n    // @ts-ignore\n    return React.cloneElement(child, getTargetRefProp(child, this.setTarget, this.addTarget));\n  };\n\n  _proto.renderTarget = function renderTarget(target) {\n    var _this3 = this;\n\n    if (!target) {\n      return null;\n    } // if is forwardRef clone and pass targets as ref\n\n\n    if (isForwardRef(target)) {\n      return this.cloneElement(target);\n    } // else iterate the first level of children and set targets\n\n\n    return React.createElement(Fragment, null, React.Children.map(target, function (child) {\n      if (isFragment(child)) {\n        return React.Children.map(child.props.children, function (fragmentChild) {\n          return _this3.cloneElement(fragmentChild);\n        });\n      }\n\n      return _this3.cloneElement(child);\n    }));\n  };\n\n  _proto.render = function render() {\n    var _this$props3 = this.props,\n        target = _this$props3.target,\n        children = _this$props3.children,\n        wrapper = _this$props3.wrapper;\n    var renderedTarget = this.renderTarget(target);\n    var output = React.createElement(Fragment, null, renderedTarget, children);\n\n    if (wrapper) {\n      output = React.cloneElement(wrapper, [], output);\n    }\n\n    return this.renderWithProvider(output);\n  };\n\n  return Timeline;\n}(Provider);\n\nTimeline.displayName = 'Timeline';\nTimeline.defaultProps = {\n  playState: PlayState.play\n};\nvar EntryState;\n\n(function (EntryState) {\n  EntryState[EntryState[\"unknown\"] = 0] = \"unknown\";\n  EntryState[EntryState[\"entered\"] = 1] = \"entered\";\n  EntryState[EntryState[\"exited\"] = 2] = \"exited\";\n})(EntryState || (EntryState = {}));\n\nvar Reveal = /*#__PURE__*/function (_Provider) {\n  _inheritsLoose(Reveal, _Provider);\n\n  function Reveal() {\n    var _this;\n\n    _this = _Provider.apply(this, arguments) || this;\n    _this.triggerRef = null;\n    _this.observer = null;\n\n    _this.intersectionObserverCallback = function (entries) {\n      var _this$props = _this.props,\n          repeat = _this$props.repeat,\n          threshold = _this$props.threshold;\n      var state = EntryState.unknown;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {\n        var entry = _step.value;\n\n        if (entry.isIntersecting && entry.intersectionRatio >= threshold) {\n          _this.timeline.play();\n\n          state = EntryState.entered;\n          break;\n        } else if (!entry.isIntersecting) {\n          state = EntryState.exited;\n          break;\n        }\n      }\n\n      if (!repeat && state === EntryState.entered) {\n        _this.killIntersectionObserver();\n      } else if (repeat && state === EntryState.exited) {\n        _this.timeline.pause(0);\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = Reveal.prototype;\n\n  _proto.init = function init() {\n    this.createTimeline();\n    this.createIntersectionObserver();\n  };\n\n  _proto.kill = function kill() {\n    this.killTimeline();\n    this.killIntersectionObserver();\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.init();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.kill();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        trigger = _this$props2.trigger; // if children change create a new timeline\n    // TODO: replace easy length check with fast equal check\n    // TODO: same for props.target?\n\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.init();\n    }\n\n    if (prevProps.trigger !== trigger) {\n      this.init();\n    }\n  };\n\n  _proto.createTimeline = function createTimeline() {\n    var _this2 = this;\n\n    this.killTimeline(); // init timeline\n\n    this.timeline = gsap$2.timeline({\n      smoothChildTiming: true,\n      paused: true\n    }); // add consumers\n\n    this.consumers.forEach(function (consumer) {\n      var position = consumer.props.position;\n\n      _this2.timeline.add(consumer.getGSAP().play(), nullishCoalescing(position, 0));\n    });\n  };\n\n  _proto.killTimeline = function killTimeline() {\n    if (this.timeline) {\n      this.timeline.kill();\n    }\n  };\n\n  _proto.createIntersectionObserver = function createIntersectionObserver() {\n    var _this3 = this;\n\n    var _this$props3 = this.props,\n        root = _this$props3.root,\n        rootMargin = _this$props3.rootMargin,\n        threshold = _this$props3.threshold;\n    var options = {\n      root: root,\n      rootMargin: rootMargin,\n      threshold: [0, threshold]\n    };\n    this.observer = new IntersectionObserver(this.intersectionObserverCallback, options); // It would be better if we wouldn't need an extra wrapper.\n    // But it can be problematic for example with a fadeInLeft animation\n    // were the element is out of the viewport in the initial state.\n    // In this case there wouldn't be an intersection..\n\n    if (!this.triggerRef) {\n      this.consumers.forEach(function (consumer) {\n        consumer.getTargets().forEach(function (target) {\n          _this3.observer && _this3.observer.observe(target);\n        });\n      });\n    } else {\n      this.observer && this.observer.observe(this.triggerRef);\n    }\n  };\n\n  _proto.killIntersectionObserver = function killIntersectionObserver() {\n    this.unobserveAll();\n    this.observer = null;\n  };\n\n  _proto.unobserveAll = function unobserveAll() {\n    var _this4 = this;\n\n    if (this.observer) {\n      if (!this.triggerRef) {\n        this.consumers.forEach(function (consumer) {\n          consumer.getTargets().forEach(function (target) {\n            _this4.observer && _this4.observer.unobserve(target);\n          });\n        });\n      } else {\n        this.observer && this.observer.unobserve(this.triggerRef);\n      }\n    }\n  };\n\n  _proto.getGSAP = function getGSAP() {\n    return this.timeline;\n  };\n\n  _proto.render = function render() {\n    var _this5 = this;\n\n    var _this$props4 = this.props,\n        children = _this$props4.children,\n        trigger = _this$props4.trigger;\n    var output = trigger ? React.createElement(trigger.type, Object.assign({}, trigger.props, {\n      ref: function ref(trigger) {\n        return _this5.triggerRef = trigger;\n      }\n    }), children) : children;\n    return this.renderWithProvider(output);\n  };\n\n  return Reveal;\n}(Provider);\n\nReveal.displayName = 'Reveal';\nReveal.defaultProps = {\n  trigger: null,\n  repeat: false,\n  root: null,\n  rootMargin: '0px',\n  threshold: 0.66\n};\ngsap$2.registerPlugin(ScrollTrigger$1);\n\nvar ScrollTrigger = /*#__PURE__*/function (_Provider) {\n  _inheritsLoose(ScrollTrigger, _Provider);\n\n  function ScrollTrigger(props) {\n    var _this;\n\n    _this = _Provider.call(this, props) || this;\n    _this.scrollTrigger = null;\n    _this.targets = {};\n    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));\n    return _this;\n  } // override and pass registerConsumer to next parent provider\n\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.registerConsumer = function registerConsumer(consumer) {\n    this.context.registerConsumer(consumer);\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        scrollTrigger = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n    if (!children) {\n      this.scrollTrigger = ScrollTrigger$1.create(scrollTrigger);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.scrollTrigger) {\n      this.scrollTrigger.kill();\n    }\n  } // componentDidUpdate(prevProps: ScrollTriggerProps) {\n  //   const { trigger } = this.props;\n  //\n  //   if (trigger !== prevProps.trigger) {\n  //     console.log('prevProps.trigger', prevProps.trigger);\n  //     console.log('trigger', trigger);\n  //   }\n  // }\n  ;\n\n  _proto.getGSAP = function getGSAP() {\n    return this.scrollTrigger;\n  };\n\n  _proto.getPlugin = function getPlugin(props, targets) {\n    var triggerProp = props.trigger,\n        scrollTrigger = _objectWithoutPropertiesLoose(props, [\"children\", \"trigger\"]);\n\n    var trigger = triggerProp;\n\n    if (targets instanceof Map) {\n      if (trigger) {\n        var target = targets.get(trigger);\n\n        if (target) {\n          trigger = target;\n        }\n      } else {\n        trigger = Array.from(targets.values());\n      }\n    } else if (!trigger) {\n      trigger = targets;\n    }\n\n    return _extends({\n      trigger: trigger\n    }, scrollTrigger);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        scrollTrigger = _objectWithoutPropertiesLoose(_this$props2, [\"children\"]);\n\n    if (!children) {\n      return null;\n    }\n\n    return this.renderWithProvider(children, {\n      scrollTrigger: scrollTrigger\n    });\n  };\n\n  return ScrollTrigger;\n}(Provider);\n\nScrollTrigger.displayName = 'ScrollTrigger';\nScrollTrigger.contextType = Context;\n\nvar escapeRegExp = function escapeRegExp(regExp) {\n  var specialChars = ['$', '^', '*', '(', ')', '+', '[', ']', '{', '}', '\\\\', '|', '.', '?', '/'];\n  var regex = new RegExp('(\\\\' + specialChars.join('|\\\\') + ')', 'g');\n  return regExp.replace(regex, '\\\\$1');\n}; // TODO: possible or better to output all the refs as one array?\n\n\nvar SplitWords = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var children = _ref.children,\n      wrapper = _ref.wrapper,\n      _ref$delimiter = _ref.delimiter,\n      delimiter = _ref$delimiter === void 0 ? ' ' : _ref$delimiter;\n\n  if (typeof children !== 'string') {\n    throw new Error('SplitWords only accepts a string as child.');\n  }\n\n  var words = children.split(new RegExp(\"(\" + escapeRegExp(delimiter) + \")\", 'g'));\n  return React.createElement(React.Fragment, null, words.map(function (word, i) {\n    if (delimiter === ' ' && word === delimiter) {\n      return React.createElement(React.Fragment, {\n        key: i\n      }, \" \");\n    }\n\n    return React.cloneElement(wrapper, {\n      ref: ref,\n      key: i\n    }, word);\n  }));\n}); // TODO: possible or better to output all the refs as one array?\n\nvar SplitChars = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      wrapper = _ref2.wrapper;\n\n  if (typeof children !== 'string') {\n    throw new Error('SplitChars only accepts a string as child.');\n  }\n\n  return React.createElement(React.Fragment, null, children.split(/(?=(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))/).map(function (_char, i) {\n    // TODO: enhance check for space\n    if (_char === ' ') {\n      return React.createElement(React.Fragment, {\n        key: i\n      }, \" \");\n    }\n\n    return React.cloneElement(wrapper, {\n      ref: ref,\n      key: i\n    }, _char);\n  }));\n});\nvar SplitLetters = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  console.warn('Deprecation warning: Use SplitChars instead of SplitLetters');\n  return React.createElement(SplitChars, Object.assign({}, props, {\n    ref: ref\n  }));\n});\n\nvar Controls = /*#__PURE__*/function (_Provider) {\n  _inheritsLoose(Controls, _Provider);\n\n  function Controls() {\n    var _this;\n\n    _this = _Provider.apply(this, arguments) || this;\n    _this.sliderTouched = false;\n    _this.state = {\n      totalProgress: 0,\n      playState: undefined,\n      prevPlayState: undefined\n    };\n    _this.containerStyle = {\n      backgroundColor: '#f0f0f0',\n      padding: '10px 10px 0 10px',\n      marginTop: '10px',\n      position: 'relative',\n      zIndex: 2,\n      fontFamily: 'verdana, sans-serif',\n      fontSize: '16px',\n      border: '1px solid #ccc'\n    };\n    _this.buttonContainerStyle = {\n      margin: '0',\n      display: 'flex',\n      flexWrap: 'wrap',\n      justifyContent: 'space-between'\n    };\n    _this.buttonStyle = {\n      border: '1px solid #999',\n      backgroundColor: '#f0f0f0',\n      padding: '5px',\n      margin: '10px 10px 10px 0',\n      cursor: 'pointer'\n    };\n    _this.sliderStyle = {\n      margin: '0',\n      width: '100%'\n    };\n    _this.playStateStyle = {\n      color: '#999',\n      margin: '10px 0',\n      fontSize: '14px'\n    };\n\n    _this.onUpdate = function () {\n      if (_this.gsap && _this.slider && !_this.sliderTouched) {\n        var totalProgress = _this.gsap.getGSAP().totalProgress();\n\n        _this.slider.value = totalProgress * 100;\n      }\n    };\n\n    _this.onChange = function (event) {\n      if (_this.gsap && _this.gsap.getGSAP()) {\n        _this.gsap.getGSAP().totalProgress(event.target.value / 100);\n      }\n    };\n\n    _this.setPlayState = function (state) {\n      _this.setState(function (prevState) {\n        return {\n          playState: state,\n          prevPlayState: prevState.playState\n        };\n      });\n    };\n\n    _this.getControls = function (_totalProgress, playState) {\n      return React.createElement(\"div\", {\n        style: _this.containerStyle\n      }, React.createElement(\"input\", {\n        ref: function ref(el) {\n          return _this.slider = el;\n        },\n        type: \"range\",\n        style: _this.sliderStyle,\n        step: \"0.001\",\n        onChange: function onChange(e) {\n          return _this.onChange(e);\n        },\n        onMouseDown: function onMouseDown() {\n          return _this.sliderTouched = true;\n        },\n        onMouseUp: function onMouseUp() {\n          return _this.sliderTouched = false;\n        }\n      }), React.createElement(\"div\", {\n        style: _this.buttonContainerStyle\n      }, React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        style: _this.buttonStyle,\n        onClick: function onClick() {\n          return _this.setPlayState(PlayState.play);\n        }\n      }, \"Play\"), React.createElement(\"button\", {\n        type: \"button\",\n        style: _this.buttonStyle,\n        onClick: function onClick() {\n          return _this.setPlayState(PlayState.reverse);\n        }\n      }, \"Reverse\"), React.createElement(\"button\", {\n        type: \"button\",\n        style: _this.buttonStyle,\n        onClick: function onClick() {\n          return _this.setPlayState(PlayState.pause);\n        }\n      }, \"Pause\"), React.createElement(\"button\", {\n        type: \"button\",\n        style: _this.buttonStyle,\n        onClick: function onClick() {\n          return _this.setPlayState(PlayState.stop);\n        }\n      }, \"Stop\")), React.createElement(\"span\", {\n        style: _this.playStateStyle\n      }, playState)));\n    };\n\n    return _this;\n  }\n\n  var _proto = Controls.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.consumers.length) {\n      this.gsap = this.consumers[0];\n      var gsap = this.gsap.getGSAP();\n\n      if (gsap) {\n        gsap.eventCallback('onUpdate', this.onUpdate);\n\n        if (this.props.playState) {\n          this.setPlayState(this.props.playState);\n        } else {\n          // get child initial state\n          if (gsap.paused()) {\n            this.setPlayState(PlayState.pause);\n          } else if (gsap.reversed()) {\n            this.setPlayState(PlayState.reverse);\n          } else {\n            this.setPlayState(PlayState.play);\n          }\n        }\n\n        var totalProgress = gsap.totalProgress();\n        this.slider.value = totalProgress * 100;\n      }\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.onUpdate();\n  };\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    var _this$state = this.state,\n        totalProgress = _this$state.totalProgress,\n        playState = _this$state.playState,\n        prevPlayState = _this$state.prevPlayState;\n\n    if (this.gsap) {\n      setPlayState(playState, prevPlayState, this.gsap.getGSAP());\n    }\n\n    return this.renderWithProvider(React.createElement(\"div\", null, children, this.getControls(totalProgress, playState)));\n  };\n\n  return Controls;\n}(Provider);\n\nexport { Controls, PlayState, Reveal, ScrollTrigger, SplitChars, SplitLetters, SplitWords, Timeline, Tween };","map":null,"metadata":{},"sourceType":"module"}